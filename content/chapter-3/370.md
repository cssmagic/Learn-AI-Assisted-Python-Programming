---
idxx: 2
title: "[译] [XXX] XXXXXXXXXXXXXXXX"
---


## 3.7 Summary
## 2.6 本章小结

* Problem decomposition involves breaking a large problem into smaller tasks.

* * We use functions to perform problem decomposition in our programs. Each function must solve one small, well-defined task.

* Functions reduce duplication, make it easier to test our code, and reduce the likelihood of bugs.

* Unit testing involves checking that the function does what we expect on a variety of different inputs.

* * A function header or signature is the first line of code of the function. Parameters are used to provide information to functions.

* The function header indicates the name of the function and names of its parameters.

* We use the return keyword to output a value from a function.

* A docstring uses the names of each function parameter to describe the purpose of the function.

* To ask Copilot to write a function, we provide it the function header and docstring.

* We get a function to do its work by calling it with values (also called arguments) for its parameters.

* A variable is a name that refers to a value.

* A helper function is a small function written to make it easier to write a bigger function.

  

* A leaf function doesn't call any other function to do its job.

* To test whether a function is correct, we call it with different types of inputs.

* Every Python value has a type, such as a number, text (string), true/false value (bool) or collection of values (list or dictionary).

* Prompt engineering involves modifying our prompt for Copilot to influence the code that we get back.

* We need to ensure that we import any module (such as string) that our code is using.

<!-- -->
